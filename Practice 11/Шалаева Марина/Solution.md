# Задание 11

## Задача 1

Транзакции требуются в системах баз данных для обработки параллельных изменений.
Транзакций можно избежать с помощью чисто поисковых приложений (только для чтения).
Объясните, почему в приложениях, которые также выполняют операции по изменению,
нельзя избежать транзакций для наших читателей. Приведите несколько примеров.

## Решение

Пользователь, работающий в приложении, в котором он может влиять на данные тем или иным образом,
рано или поздно обязательно столкнется с тем, что другой пользователь повлияет на данные, с которыми он работает.

Пример: при заказе товаров из одного и того же продуктового магазина два покупателя захотят приобрести один и тот
же пакет молока. На складе, допустим, остался всего один такой пакет, и когда кто-то из покупателей оплатит заказ, второй
уже не должен суметь его приобрести: во избежании казусов ему должно прийти уведомление, что данный товар раскупили, 
ведь приобрести товар, которого уже нет, нельзя.

Другой пример: пользователь хочет оплатить покупку на сумму 200 рублей картой, количество денег на которой
не может уходить в минус.
Покупатель зашел в приложение банка, в котором отображается, сколько денег у него на данный момент:
например, ровно 200 рублей, которых должно хватить на оплату покупки.
Пока пользователь стоял в очереди, произошло неожиданное: некое приложение (к примеру, для прослушивания музыки),
в котором у героя нашего рассказа есть платная подписка, автоматически списало с карты стоимость ежемесячной
услуги в размере 200 рублей.
Если бы можно было избежать транзакции для пользователя, он смог бы оплатить покупку,
тем самым воспользовавшись одними и теми же деньгами дважды:
один раз оплатил бы услугу приложения, второй — оплатил бы покупку в магазине, поскольку
в открытом приложении банка состояние счета не изменилось бы.

## Задача 2

Найдите все возможные истории транзакций T1 и T2 и укажите их свойства сериализуемости.

```
T1: Read (A);
A: = A - N;
Write (A);
Read (B);
B: = B + N;
Write (B);
T2: Read (A);
A: = A + M;
Write (A);
```

## Решение

К конфликту приводят следующие пары значений:
1. r1(A); w2(A)
2. r2(A); w1(A)
3. w1(A); r2(A)
4. w2(A); r1(A)
5. w1(A); w2(A)
6. w2(A); w1(A)

=> в данной серии есть 4 неэквивалетных варианта:
1) w2(A) идет после r1(A) и w1(A). Например: `r1(A) r2(A) w1(A) r1(B) w1(B) w2(A)` — серия не сериализуема
2) r2(A) идет после w1(A). Например: `r1(A) w1(A) r1(B) w1(B) r2(A) w2(A)` — серия сериализуема
3) r1(A) идет после w2(A). Например: `r2(A) w2(A) r1(A) w1(A) r1(B) w1(B)` — серия сериализуема
4) сначала идет r1(A), затем w2(A), затем w1(A). Например: `r1(A) r2(A) w2(A) w1(A) r1(B) w1(B)` — серия не сериализуема

## Задача 3

Исследуйте транзакции T1, T2, T3, T4, выполняя операции над объектами A, B, C, D, E. Рассмотрим следующие истории:

* H1) r1(A) r2(B) r3(B) r3(C) w2(A) r2(D) r1(A) w1(B) w2(D) r1(A) w2(C) w2(B) r2(B) w3(B) r2(B) c2 w4(C) r4(C) w4(A) c1 c4 c3
* H2) r1(A) r2(C) w3(D) w1(A) r1(D) w2(A) r2(B) r2(C) w2(B) w3(C) r2(A) w1(B) r1(B) r3(D) w1(B) c1 r3(B) c2 c3
* H3) r1(E) r2(B) r2(A) w2(B) w2(A) w1(B) r2(D) r2(E) r3(E) r2(A) r2(C) w2(A) w2(D) r1(A) w2(C) w1(A) r1(C) r2(E) r3(D) r1(A) w3(D) w1(A) r3(A) w1(C) r3(A) w1(B) r3(C) r3(B) r3(C) w3(A) c1 c2 c3
* H4) r3(A) r2(C) r1(B) w1(A) r1(C) r2(A) a1 w2(C) c2 r3(C) c3

Какие истории сериализуемы? Для каждой сериализуемой истории покажите эквивалентную последовательную историю.
Как 2PL и изоляция снапшотов ведут себя в этой последовательности операций? Разрешены ли эти истории?
Если да, существуют ли какие-либо возможные несоответствия с изоляцией снапшотов (snapshot)?

## Решение

## Задача 4

Можно ли сериализовать следующую историю? Если это так, укажите эквивалентную историю серий. Если нет, скажите, почему.

* T1: Select sum (money) from account;
* T2: Insert into account (account#, money) values (123, 0); commit
* T2: Commit;
* T1: Select avg (money) from account;
* T1: Commit;

## Решение

Рассмотрим две возможные серии: `T1; T2` и `T2; T1`.

```
T1: Select sum (money) from account;
T1: Select avg (money) from account;
T1: Commit;

T2: Insert into account (account#, money) values (123, 0); commit
T2: Commit;
```

Insert и Select avg здесь будут выполняться в ином порядке, чем предполагалось изначально, что повлияет на результат => данная серия не будет эквивалетной исходной.

```
T2: Insert into account (account#, money) values (123, 0); commit
T2: Commit;

T1: Select sum (money) from account;
T1: Select avg (money) from account;
T1: Commit;
```

В данном случае меняется порядок Insert и Select sum, что в данном случае не повлияет на результат, поскольку `money = 0`. Данная серия будет эквивалетна исходной.

Ответ: сериализовать данную серию можно: эквивалентная ей серия — `T2; T1`.

## Задача 5

Объясните, почему ограничения целостности проверяются только в конце транзакции. Какие из свойств ACID требуются при таком подходе?

## Решение

Есть множество случаев, при которых последовательность действий выполняющихся параллельно транзакций противоречит друг другу, из-за чего
условие целостности может быть нарушено. Благодаря первому свойству ACID (атомарность) мы можем не требовать выполнения условия
целостности в середине транзакции, поскольку мы уверены в том, что транзакция будет либо успешно выполнена, либо не будет выполнена вовсе.
Тогда соблюдение условия целостности необходимо до начала транзакции и после ее окончания.
